---
title: 《大话数据结构》读后总结（十一）
date: 2019-02-25 11:47:28
tags: 【数据结构，算法】
categories: "大话数据结构"
top: 0
---

### 单链表的读取

单链表第 i 个数据的算法思路：

1. 声明一个指针 p 指向链表第一个结点，初始化 j 从 1 开始；

2. 当 j<i 时，就遍历链表，让 p 的指针向后移动，不断指向下一结点，j 累加 1；

3. 若到链表末尾 p 为空，则说明第 i 个结点不存在；

4. 否则查找成功，返回结点 p 的数据。

```c
/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */
/* 操作结果：用e返回L中第i个数据元素的值 */
Status GetElem(LinkList L, int i, ElemType *e)
{
    int j;
    LinkList p;            /* 声明一指针p */
    p = L->next;        /* 让p指向链表L的第个结点 */
    j = 1;                 /* j为计数器 */
    /* p不为空且计数器j还没有等于i时，循环继续 */
    while (p && j < i)
    {
        p = p->next;    /* 让p指向下一个结点 */
        ++j;
    }
    if (!p || j > i)
        return ERROR;      /* 第i个结点不存在 */
    *e = p->data;       /* 取第i个结点的数据 */
    return OK;
}
```

从头开始找，直到第 i 个结点为止。由于这个算法的时间复杂度取决于 i 的位置，当 i=1 时，则不需遍历，第一个就取出数据了，而当 i=n 时则遍历 n-1 次才可以。因此最坏情况的时间复杂度是 O(n)。

### 单链表的插入与删除

#### 单链表的插入

![](http://ww1.sinaimg.cn/large/a616b9a4gy1g4y027yrq5j20lc0dpwep.jpg)

```c
s->next = p->next; p->next = s;
```

单链表第 i 个数据插入结点的算法思路：

1. 声明一指针 p 指向链表头结点，初始化 j 从 1 开始；

2. 当 j<i 时，就遍历链表，让 p 的指针向后移动，不断指向下一结点，j 累加 1；

3. 若到链表末尾 p 为空，则说明第 i 个结点不存在；

4. 否则查找成功，在系统中生成一个空结点 s；

5. 将数据元素 e 赋值给 s->data；

6. 单链表的插入标准语句 s->next=p->next;p->next=s；

7. 返回成功。

```c
/* 初始条件：顺序线性表L已存在，1≤i≤
   ListLength(L)， */
/* 操作结果：在L中第i个结点位置之前插入新的数
   据元素e，L的长度加1 */
Status ListInsert(LinkList *L, int i, ElemType e)
{
    int j;
    LinkList p, s;
    p = *L;
    j = 1;
    /* 寻找第i-1个结点 */
    while (p && j < i)
    {
        p = p->next;
        ++j;
    }
    /* 第i个结点不存在 */
    if (!p || j > i)
        return ERROR;
    /* 生成新结点（C标准函数） */
    s = (LinkList)malloc(sizeof(Node));
    s->data = e;
    /* 将p的后继结点赋值给s的后继 */
    s->next = p->next;
    /* 将s赋值给p的后继 */
    p->next = s;
    return OK;
}
```

#### 单链表的删除

![](http://ww1.sinaimg.cn/large/a616b9a4gy1g4y0jza8zaj20w00bfjrj.jpg)

```c
q=p->next; p->next=q->next;
```

单链表第 i 个数据删除结点的算法思路：

1. 声明一指针 p 指向链表头结点，初始化 j 从 1 开始；

2. 当 j<i 时，就遍历链表，让 p 的指针向后移动，不断指向下一个结点，j 累加 1；

3. 若到链表末尾 p 为空，则说明第 i 个结点不存在；

4. 否则查找成功，将欲删除的结点 p->next 赋值给 q；

5. 单链表的删除标准语句 p->next=q->next；

6. 将 q 结点中的数据赋值给 e，作为返回；

7. 释放 q 结点；

8. 返回成功。

```c
/* 初始条件：顺序线性表L已存在，1≤i≤
   ListLength(L) */
/* 操作结果：删除L的第i个结点，并用e返回其
   值，L的长度减1 */
Status ListDelete(LinkList *L, int i, ElemType *e)
{
    int j;
    LinkList p, q;
    p = *L;
    j = 1;
    /* 遍历寻找第i-1个结点 */
    while (p->next && j < i)
    {
        p = p->next;
        ++j;
    }
    /* 第i个结点不存在 */
    if (!(p->next) || j > i)
        return ERROR;
    q = p->next;
    /* 将q的后继赋值给p的后继 */
    p->next = q->next;
    /* 将q结点中的数据给e */
    *e = q->data;
    /* 让系统回收此结点，释放内存 */
    free(q);
    return OK;
}
```

### 总结

单链表插入和删除算法，都是由两部分组成：第一部分就是遍历查找第 i 个结点；第二部分就是插入和删除结点。
它们的时间复杂度都是 O(n)。

如果在我们不知道第 i 个结点的指针位置，单链表数据结构在插入和删除操作上，与线性表的顺序存储结构是没有太大优势的。但如果，我们希望从第 i 个位置，插入 10 个结点，对于顺序存储结构意味着，每一次插入都需要移动 n-i 个结点，每次都是 O(n)。而单链表，我们只需要在第一次时，找到第 i 个位置的指针，此时为 O(n)，接下来只是简单地通过赋值移动指针而已，时间复杂度都是 O(1)。显然，对于插入或删除数据越频繁的操作，单链表的效率优势就越是明显。

### 欢迎扫描下方二维码，持续关注：

![](http://ww1.sinaimg.cn/large/a616b9a4gy1g4xzv954a4j20760763yo.jpg)

互联网工程师（id:phpstcn），我们一起学习，一起进步
